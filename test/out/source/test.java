/* autogenerated by Processing revision 1286 on 2022-09-09 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import org.apache.commons.math3.ml.neuralnet.*;
import org.apache.commons.math3.ml.neuralnet.twod.*;
import org.apache.commons.math3.ml.neuralnet.twod.util.*;
import org.apache.commons.math3.ml.neuralnet.oned.*;
import org.apache.commons.math3.ml.neuralnet.sofm.*;
import org.apache.commons.math3.ml.neuralnet.sofm.util.*;
import org.apache.commons.math3.ml.clustering.*;
import org.apache.commons.math3.ml.clustering.evaluation.*;
import org.apache.commons.math3.ml.distance.*;
import org.apache.commons.math3.analysis.*;
import org.apache.commons.math3.analysis.differentiation.*;
import org.apache.commons.math3.analysis.integration.*;
import org.apache.commons.math3.analysis.integration.gauss.*;
import org.apache.commons.math3.analysis.function.*;
import org.apache.commons.math3.analysis.polynomials.*;
import org.apache.commons.math3.analysis.solvers.*;
import org.apache.commons.math3.analysis.interpolation.*;
import org.apache.commons.math3.stat.interval.*;
import org.apache.commons.math3.stat.ranking.*;
import org.apache.commons.math3.stat.clustering.*;
import org.apache.commons.math3.stat.*;
import org.apache.commons.math3.stat.inference.*;
import org.apache.commons.math3.stat.correlation.*;
import org.apache.commons.math3.stat.descriptive.*;
import org.apache.commons.math3.stat.descriptive.rank.*;
import org.apache.commons.math3.stat.descriptive.summary.*;
import org.apache.commons.math3.stat.descriptive.moment.*;
import org.apache.commons.math3.stat.regression.*;
import org.apache.commons.math3.linear.*;
import org.apache.commons.math3.*;
import org.apache.commons.math3.distribution.*;
import org.apache.commons.math3.distribution.fitting.*;
import org.apache.commons.math3.complex.*;
import org.apache.commons.math3.ode.*;
import org.apache.commons.math3.ode.nonstiff.*;
import org.apache.commons.math3.ode.events.*;
import org.apache.commons.math3.ode.sampling.*;
import org.apache.commons.math3.random.*;
import org.apache.commons.math3.primes.*;
import org.apache.commons.math3.optim.*;
import org.apache.commons.math3.optim.linear.*;
import org.apache.commons.math3.optim.nonlinear.vector.*;
import org.apache.commons.math3.optim.nonlinear.vector.jacobian.*;
import org.apache.commons.math3.optim.nonlinear.scalar.*;
import org.apache.commons.math3.optim.nonlinear.scalar.gradient.*;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.*;
import org.apache.commons.math3.optim.univariate.*;
import org.apache.commons.math3.exception.*;
import org.apache.commons.math3.exception.util.*;
import org.apache.commons.math3.fitting.leastsquares.*;
import org.apache.commons.math3.fitting.*;
import org.apache.commons.math3.dfp.*;
import org.apache.commons.math3.fraction.*;
import org.apache.commons.math3.special.*;
import org.apache.commons.math3.geometry.*;
import org.apache.commons.math3.geometry.hull.*;
import org.apache.commons.math3.geometry.enclosing.*;
import org.apache.commons.math3.geometry.spherical.twod.*;
import org.apache.commons.math3.geometry.spherical.oned.*;
import org.apache.commons.math3.geometry.euclidean.threed.*;
import org.apache.commons.math3.geometry.euclidean.twod.*;
import org.apache.commons.math3.geometry.euclidean.twod.hull.*;
import org.apache.commons.math3.geometry.euclidean.oned.*;
import org.apache.commons.math3.geometry.partitioning.*;
import org.apache.commons.math3.geometry.partitioning.utilities.*;
import org.apache.commons.math3.optimization.*;
import org.apache.commons.math3.optimization.linear.*;
import org.apache.commons.math3.optimization.direct.*;
import org.apache.commons.math3.optimization.fitting.*;
import org.apache.commons.math3.optimization.univariate.*;
import org.apache.commons.math3.optimization.general.*;
import org.apache.commons.math3.util.*;
import org.apache.commons.math3.genetics.*;
import org.apache.commons.math3.transform.*;
import org.apache.commons.math3.filter.*;

import peasy.*;
import org.apache.commons.math3.linear.MatrixUtils;
import org.apache.commons.math3.linear.RealMatrix;
import processing.core.PShape;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Vector;
import static java.lang.Math.*;
import static processing.core.PConstants.PI;
import shapes3d.*;
import shapes3d.contour.*;
import shapes3d.org.apache.commons.math.*;
import shapes3d.org.apache.commons.math.geometry.*;
import shapes3d.path.*;
import shapes3d.utils.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class test extends PApplet {



 private final int NX = 1;
    private final int NY = 1;
    private final int bgColor = color(51,102,102);
    private Robot r;
    private final PeasyCam[] cameras = new PeasyCam[NX * NY];
  private int padding = 10;
 public void settings() {
        int WIDTH3D = 1366;
        int HEIGHT3D = 768;
        size(WIDTH3D, HEIGHT3D, P3D);
        pixelDensity(1);
        smooth(8);
    }
 public void setup(){
  //size(1000,1000,P3D);
  rectMode(CENTER);
        r = new Robot();
        //setGradient(0, 0, width, height, c1, c2, Y_AXIS);
        int tilex = floor((width-padding) / NX);
        int tiley = floor((height-padding) / NY);

        // viewport offset ... corrected gap due to floor()
        int offx = (width - (tilex * NX-padding)) / 2;
        int offy = (height - (tiley * NY-padding)) / 2;

        // viewport dimension
        int cw = tilex - padding;
        int ch = tiley - padding;

        // create new viewport for each camera
        for (int y = 0; y < NY; y++) {
            for (int x = 0; x < NX; x++) {
                int id = y * NX + x;
                int cx = offx + x * tilex;
                int cy = offy + y * tiley;
                if(x == 0) cameras[id] = new PeasyCam(this, 300);
                else cameras[id] = new PeasyCam(this, 500);
                cameras[id].setViewport(cx, cy, cw, ch); // this is the key of this whole demo
            }
        }
}
public PeasyCam setupScene(PeasyCam cam,int id) {
        //!! Begin camera setup
        
        int[] viewport = cam.getViewport();
        int w = viewport[2];
        int h = viewport[3];
        int x = viewport[0];
        int y = viewport[1];
        int y_inv = height - y - h; // inverted y-axis
        // scissors-test and viewport transformation
        setGLGraphicsViewport(x, y_inv, w, h);
        // set camera state like spinning a globe
        cam.setYawRotationMode();
        cam.setRightDragHandler(null);
        cam.setCenterDragHandler(null);
        switch(id){
            case 0:              
                cam.setMinimumDistance(300);
                cam.setMaximumDistance(1000);
                break;
        }
        cam.feed();
        // projection - using camera viewport
        perspective(60 * PI / 180, w / (float) h, 1, 5000);
        // clear background (scissors makes sure we only clear the region we own)
//        background(51, 102, 153);
        background(bgColor);
        // Ruoto il mondo per settare
        // Z > 0 su, X > 0 a destra, Y > 0 in avanti
        scale(1,-1,1);
        rotateX(-PI / 2);
        rotateZ(-PI/2);
        //!! End camera setup
        return cam;
    }
    float th = 0;
 public void draw(){
   setGLGraphicsViewport(0, 0, width, height);
        background(153,204,153);
        // Aggiungo degli effetti di luce direzionale
        directionalLight(126F, 126F, 126F, (float) -1, (float) 1, (float) -0.7f);
        // Aggiungo degli effetti di luce ambientale
        ambientLight(200, 200, 200);
        // setup bg
        for (int i = 0; i < cameras.length; i++) {
            pushStyle();
            pushMatrix();
            switch (i) {
                case 0: draw3Drobot(setupScene(cameras[i],i)); break;
            }
            popMatrix();
            popStyle();
        }
        
}


 public void keyPressed(){
  switch(key){
    case 'a': px +=1; break;
    case 'z': px -=1;break;
    case 's': py +=1;break;
    case 'x': py -=1;break;
    case 'd': pz +=1;break;
    case 'c': pz -=1;break;
  }
  if (key == '1') {
            r.setJoint(0,0.2f);
        }
        if (key == '2') {
            r.setJoint(1,0.2f);
        }
        if (key == '3') {
            r.setJoint(2,0.2f);
        }
        if (key == '4') {
            r.setJoint(3,0.2f);
        }
        if (key == '5') {
            r.setJoint(4,0.2f);
        }
        if (key == '6') {
            r.setJoint(5,0.2f);
        }
        if (key=='q'){
          roll =roll+0.2f;
        }
        
        if (key=='w'){
         pitch =pitch+0.2f;
        }
        
        if (key=='e'){
          yaw =yaw+0.2f;
        }
        if(key == 'm'){
          dx = dx+1;
          println(dx);
        } 
        if (key == 'n'){
          dx = dx-1;
          println(dx);
        }
        if(key == 'e'){
          elbow = -elbow;
        }  
}
int box_size = 10;
public void show(float x, float y, float z, boolean show) {
        int length = 100;
        // reference coordinates
        pushMatrix();
        translate(x, y, z);
        float alpha = show ? 255.0f : 0.0f;
        strokeWeight(3);
        // x-axis
        stroke(255,0,0,alpha);
        line(0,0,0,length,0,0);
        // y-axis
        stroke(0,255,0,alpha);
        line(0,0,0,0,length,0);
        // z-axis
        stroke(0,0,255,alpha);
        line(0, 0, 0, 0, 0,length);
        // show

        if (show) {
            strokeWeight(1);
            stroke(0);
            fill(153,204,204);
            box(box_size);
            noFill();
        }
        noStroke();
        popMatrix();

    }
     float roll = -PI/4;
     float pitch = PI/3;
     float yaw = PI/4;
     //     float roll =0;
     //float pitch = 0;
     //float yaw = 0;
     float px= 0;
float py= 80f;
float pz = 50f;
int dx = 0;
Ellipsoid shape;
int elbow = 1;
public void draw3Drobot(PeasyCam cam){
        //show(0,0,0,true);
        //th = th+0.02;
        //pushMatrix();
        //rotateY(th);
        //show(0,0,0,true);
        //popMatrix();
         
        fill(255);
        stroke(0);
        strokeWeight(3);
        pushMatrix();
        translate(px,py,pz);
        //show(0,0,96+dx,true);    
        rotateZ(roll);
        rotateY(pitch);
        rotateZ(yaw);
        //show(0,0,0,true);
        //box(5);
        //show(0,0,63,true);
        popMatrix();
        noStroke();                
        //translate(0,0,-32);
          r.setDhTable(r.inverseKinematics(px,py,pz,roll,pitch,yaw,elbow));

        pushMatrix();
         r.drawLink();
         //show(0,0,0,true);
         
        popMatrix();
       pushMatrix();

        translate(0.0f, 0.0f, 33);
        //fill(color(20,200,150));
        stroke(0);
        strokeWeight(2);
        //sphere(abs(a2 - d4));
        //sphere(50+51);
        //shape = new Ellipsoid(50+51, 50+51, 50+51, 24, 12);
        //shape.fill(color(1,1,1, 0.5));
        //shape.drawMode(S3D.WIRE);
        //shape.draw(getGraphics());
        popMatrix();
        cam.beginHUD();


        cam.endHUD();
    }
public void setGLGraphicsViewport(int x, int y, int w, int h) {
    PGraphics3D pg = (PGraphics3D) this.g;
    PJOGL pgl = (PJOGL) pg.beginPGL();
    pg.endPGL();
    pgl.enable(PGL.SCISSOR_TEST);
    pgl.scissor(x, y, w, h);
    pgl.viewport(x, y, w, h);
}  
















public class Robot {
    // Theta
    private float[] q = new float[]{0, -PI / 2, PI / 2, 0, 0, 0};
    //private float[] q = new float[]{-2.4004,2.1881,-3.1451,-23.9823,1.2456,26.1715};
    // d
    private final float d1 = 33.0f;
    private final float d2 = 0.0f;
    private final float d3 = 0.0f;
    private final float d4 = 51.0f;
    private final float d5 = 0.0f;
    private final float d6 = 12.0f;
    private final float[] d = new float[]{d1, d2, d3, d4, d5, d6};
    // Alpha
    private final float alpha1 = -PI / 2;
    private final float alpha2 = 0.0f;
    private final float alpha3 = PI / 2;
    private final float alpha4 = -PI / 2;
    private final float alpha5 = PI / 2;
    private final float alpha6 = 0;
    private final float[] alpha = new float[]{alpha1, alpha2, alpha3, alpha4, alpha5, alpha6};
    // a
    private final float a1 = 0.0f;
    private final float a2 = 50.0f;
    private final float a3 = 0.0f;
    private final float a4 = 0.0f;
    private final float a5 = 0.0f;
    private final float a6 = 0.0f;
    private final float[] a = new float[]{a1, a2, a3, a4, a5, a6};
    // displacement for first link
    private final float offset1 = 29.0f;
    // DH Table
    private Vector<Vector<Float>> dhTable = new Vector<>();
    // Model storage
    private final ArrayList<PShape> shapeList = new ArrayList<>();
    // scalefactor for shapes
    private float scaleFactor;
    
    
    // Observers
    public Robot() {
        this.shapeList.add(loadLink(0));
        for (int i = 0; i < 6; i++) {
            // load link_i
            this.shapeList.add(loadLink(i + 1));
            // Assign DH table
            Vector<Float> dhRow = new Vector<>(Arrays.asList(q[i], d[i], alpha[i], a[i]));
            dhTable.add(dhRow);
        }
    }
    Ellipsoid shape;
    public void dh(float theta, float d, float alpha, float a) {
        rotateZ(theta);
        translate(0, 0, d);
        rotateX(alpha);
        translate(a, 0, 0);
    }
    private PShape loadLink(int id) {
        File file = sketchFile("models/r" + id + "c.obj");
        String objPath = file.getAbsolutePath();
        PShape shape = loadShape(objPath);
        if (id == 0) {
            //  scaleFactor = 30.0f;
            scaleFactor = 9f;
        } else {
            scaleFactor = 1;
        }
        shape.scale(scaleFactor);
        return shape;
    }
    public void drawLink() {
        this.getShapeList().get(0).setFill(color(102,51,0));
        //! Offset dalla mappa 9.5        
        pushMatrix();
        rotateX(PI / 2);
        //rotateY(PI/2);
        shape(this.getShapeList().get(0));
        popMatrix();                          
        
        // dh 01
        Vector<Float> r01 = this.getDhTable().get(0);
        this.dh(r01.get(0), r01.get(1), r01.get(2), r01.get(3));
        this.getShapeList().get(1).setFill(color(100, 200, 0));
        pushMatrix();
        //  zeroFrame = new Reference(p3d,new PVector(0,0,0));
        //  zeroFrame.show(true);
        //show(0,dx,0,true);
        rotateY( -PI / 2);
        rotateZ(PI);
        translate(0, -25, 0);
        shape(this.getShapeList().get(1));
        popMatrix();
        // dh 12
        Vector<Float> r12 = this.getDhTable().get(1);
        this.dh(r12.get(0), r12.get(1), r12.get(2), r12.get(3));
        this.getShapeList().get(2).setFill(color(40, 2, 100));
        pushMatrix();
        translate( -50,0,0);
        rotateY(PI / 2);
        shape(this.getShapeList().get(2));
        popMatrix();
        // dh 23
        Vector<Float> r23 = this.getDhTable().get(2);
        this.dh(r23.get(0), r23.get(1), r23.get(2), r23.get(3));
        this.getShapeList().get(3).setFill(color(100, 200, 0));
        pushMatrix();
        //  zeroFrame = new Reference(this,new PVector(0,0,0));
        //  zeroFrame.show(true);
        rotateZ(PI / 2);
        rotateX( -PI);
        shape(this.getShapeList().get(3));
        popMatrix();
        // dh 34
        Vector<Float> r34 = this.getDhTable().get(3);
        this.dh(r34.get(0), r34.get(1), r34.get(2), r34.get(3));
        this.getShapeList().get(4).setFill(color(40, 2, 100));
        pushMatrix();
        //  zeroFrame = new Reference(p3d,new PVector(0,0,0));
        //  zeroFrame.show(true);
        
        translate(0, 51, 0);
        rotateX( -PI / 2);
        rotateZ(PI / 2);
        shape(this.getShapeList().get(4));
        popMatrix();
        // dh 45
        Vector<Float> r45 = this.getDhTable().get(4);
        this.dh(r45.get(0), r45.get(1), r45.get(2), r45.get(3));
        this.getShapeList().get(5).setFill(color(100, 200, 0));
        pushMatrix();
        //  zeroFrame = new Reference(p3d,new PVector(0,0,0));
        //  zeroFrame.show(true);
        translate(0, 0, -1);
        rotateZ(PI / 2);
        shape(this.getShapeList().get(5));
        popMatrix();
        stroke(0);
        strokeWeight(1);
        //sphere(abs(a2 - d4));
        sphere(d6);
        noStroke();stroke(0);
        strokeWeight(1);
        //sphere(abs(a2 - d4));
        //sphere(d6);
        noStroke();
        // dh 56
        Vector<Float> r56 = this.getDhTable().get(5);
        this.dh(r56.get(0), r56.get(1), r56.get(2), r56.get(3));
        
        this.getShapeList().get(6).setFill(color(40, 2, 100));
        pushMatrix();
        //  zeroFrame = new Reference(p3d,new PVector(0,0,0));
        //  zeroFrame.show(true);
        //show(0,0,0,true);
        translate(0, 0, -13);
        shape(this.getShapeList().get(6));
        popMatrix();
    }
    
    public Vector<Float> getDHrow(int rIndex) {
        return this.dhTable.get(rIndex);
    }
    public Vector<Vector<Float>> getDhTable() {
        return this.dhTable;
    }
    public void setDhTable(Vector<Vector<Float>> newTable) { this.dhTable = newTable;}
    public void setDhTable(float[] joints) {
        int id = 0;
        for (float q : joints) {
            this.setJoint(id, q);
            id += 1;
        }
    }
    public void setJoint(int rIndex, float qNew) {
        Vector<Float> tempRow = getDHrow(rIndex);
        //tempRow.set(0, tempRow.get(0)+qNew);
        tempRow.set(0,qNew);
        this.dhTable.set(rIndex, tempRow);
    }
    public void setDistance(int rIndex, int cIndex, float dNew) {
        Vector<Float> tempRow = getDHrow(rIndex);
        tempRow.set(cIndex, tempRow.get(1) + dNew);
        this.dhTable.set(rIndex, tempRow);
    }
    
    public PShape getShape(int id) {
        return this.shapeList.get(id);
    }
    public ArrayList<PShape> getShapeList() {
        return this.shapeList;
    }
    
    
    //private float xdes, ydes, zdes = 0;
    
    public float[] inverseKinematics(float xdes, float ydes, float zdes,float roll, float pitch, float yaw, int elbow) {
        //println(xdes);
        //println(ydes);
        //println(zdes);
        /* inversa di po
        sizione */
        // posizione del polso
        float xh = xdes - d6 * cos(roll) * sin(pitch);
        float yh = (ydes - d6 * sin(roll) * sin(pitch));
        float zh = zdes - d6 * cos(pitch);
        // setups for next calculations
        float B2 = -elbow * sqrt(pow(xh,2) + pow(yh,2));
        float B1 = d1 - zh;
        
        // sin(q[3])
        float ds3 = 2 * a2 * d4;
        float ns3 = pow(B1,2) + pow(yh,2) + pow(xh,2) - pow(a2,2) - pow(d4,2);
        float s3 = (ns3) / ds3;
        // cos(q[3])
        float c3 = elbow * sqrt(1 - pow(s3,2));
        // q[3]
        float q3 = atan2((s3),(c3));
        // setups for next calculations
        //float A12 =( a2+d4*s3);
        //float A11 = -d4*c3;
        //float det = pow(A11,2)-pow(A12,2);
        //// cos(q[2])
        ////float c2 = -(B2*A12-A11*B1)/det;
        //// sin(q[2])
        
        //float c2  = (d2*elbow*sqrt(pow(xh,2)+pow(yh,2))-d1*d4*c3+d4*zh*c3+d4*s3*B2)/
        //(pow(a2,2)+2*s3*a2*a4+pow(d4,2));
        //float s2 = (d1*a2-a2*zh-d4*zh*s3+d1*d4*s3+d4*c3*B2)/( pow(a2,2)+2*s3*a2*a4+pow(d4,2));
        //// q[2]
        //float q2 = atan2((s2),(c2));
        float A11 = -d4 * c3;
        float A12 = a2 + d4 * s3;
        float A21 = -A12;
        float A22 = A11;
        float det = A11 * A22 - A12 * A21;
        float c2 = -(A12 * B2 - A22 * B1) / det;
        float s2 = (A11 * B2 - A21 * B1) / det;
        float q2 = atan2(s2,c2);
        //// another setup
        //float k = a2*c2+d4*sin(q2+q3);
        float k = a2 * c2 + d4 * (s2 * c3 + c2 * s3);
        // cos(q[1])
        float c1 = xh / k;
        // sin(q[1])
        float s1 = yh / k;
        // q[1]
        float q1 = atan2((s1),(c1));
        /* inversa di orientamento */
        // Setup for next calculations
        RealMatrix zRoll = MatrixUtils.createRealMatrix(rotateZm(roll));
        RealMatrix yPitch = MatrixUtils.createRealMatrix(rotateYm(pitch));
        RealMatrix zYaw = MatrixUtils.createRealMatrix(rotateZm(yaw));
        //RealMatrix xYaw = MatrixUtils.createRealMatrix(rotateXm(yaw));
        RealMatrix Rdes = zRoll.multiply(yPitch).multiply(zYaw);
        Vector<Vector<Float>> dh03 = new Vector<Vector<Float>>();
        dh03.add(getDhTable().get(0));
        dh03.add(getDhTable().get(1));
        dh03.add(getDhTable().get(2));
        double[][] dhValue = dhValue(dh03);
        RealMatrix Q03 = MatrixUtils.createRealMatrix(dhValue);
        RealMatrix R03T = Q03.getSubMatrix(0,2,0,2).transpose();
        RealMatrix R = R03T.multiply(Rdes);
        //printR(R);
        // q[5]
        float c5 = (float)R.getEntry(2,2);
        float s5 = elbow*sqrt(1-pow(c5,2));
        float q5 = atan2(s5,c5);
        // q[4]
        float c4 =  (float)R.getEntry(0,2)/s5;
        float s4 =  (float)R.getEntry(1,2)/s5;
        float q4 = atan2(s4,c4);
        // q[6]
        float c6 =  (float)-R.getEntry(2,0)/s5;
        float s6 =  (float)R.getEntry(2,1)/s5;
        float q6 = atan2(s6,c6);
        //println(new float[]{q1,q2,q3,q4,q5,q6});
        return new float[]{q1,q2,q3,q4,q5,q6};
    }
        
        private double [][] rotateZm(float theta){
        return new double[][]{{cos(theta), -sin(theta), 0},
        {sin(theta), cos(theta), 0},
        {0d, 0d, 1}};
    }
        private double [][] rotateYm(float theta){
        return new double[][]{{cos(theta), 0, sin(theta)},
        {0d, 1d, 0d},
        {-sin(theta),0, cos(theta)}};
    }
        private double [][] rotateXm(float theta){
        return new double[][]{{1,0,0},{0,cos(theta), -sin(theta)},{0,sin(theta), cos(theta)}};
    }
        private void printR(RealMatrix R){
        System.out.println(String.format(
        "[%f,%f,%f]\n[%f,%f,%f]\n[%f,%f,%f]",
        R.getEntry(0,0),R.getEntry(0,1),R.getEntry(0,2),R.getEntry(1,0),R.getEntry(1,1),R.getEntry(1,2),R.getEntry(2,0),R.getEntry(2,1),R.getEntry(2,2))
        );
    }
        public double [][] translateM(float x, float y, float z){
        return new double[][]{{x},{y},{z}};
    }
        public double[][] rotor(String axis, float theta, float d){
        float theta_r = (theta); //<>//
        double[][] av = new double[][]{{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,1}};
        double[][] R = new double[][]{};
        double[][] T= new double[][]{};
        if(axis.equals("x")) {
        R = rotateXm(theta_r);
        T = translateM(d,0,0);          
    } else if (axis.equals("z")){
        R = rotateZm(theta_r);
        T = translateM(0,0,d);   
    }
        for(int i = 0; i < 3; i++){
        for(int j = 0; j < 3; j++){
        av[i][j] = R[i][j];
    }
    }
        for(int k = 0; k < 3; k++){
        av[k][3] = T[k][0];
    }
        return av;
    }
        public double[][] dhValue(Vector<Vector<Float>> dhTable){
        double[][] value = new double[][]{{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,1}};
        RealMatrix Q = MatrixUtils.createRealIdentityMatrix(4);
        for (Vector<Float> dhRow : dhTable) {
        float q = dhRow.get(0);
        float d = dhRow.get(1);
        float alpha = dhRow.get(2);
        float a = dhRow.get(3);
        double[][] Qzi = rotor("z", q, d);
        double[][] Qxi = rotor("x", alpha, a);
        RealMatrix Qzim = MatrixUtils.createRealMatrix(Qzi);
        RealMatrix Qxim = MatrixUtils.createRealMatrix(Qxi);
        Q = Q.multiply(Qzim).multiply(Qxim);
    }
        for(int i =0; i < 4; i++){
        value[i] = Q.getRow(i);
    }
        return value;
    }
        public void printEF(){
        
    }
    }
        


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "test" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
